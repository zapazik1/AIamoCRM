---
title: "Механика работы"
description: "Система amoCRM – удобная web программа для анализа продаж, доступная в режиме online из любой точки мира! Подробности узнавайте по указанным на сайте телефонам в Москве."
url: https://www.amocrm.ru/developers/content/web/sdk/mechanics
section: developers
---

**Базовая структура** виджета выглядит следующим образом:

```
./
├── i18n
| └── ru.json
|
├── images
| ├── logo.png
| ├── logo\_min.png
| └── logo\_main.png
|
├── templates
| └── page.twig
|
├── manifest.json
├── style.css
└── script.js
```

| Файл | Описание |
| --- | --- |
| manifest.json | Файл в формате**json**, содержащий описание виджета, настройки виджета, параметры виджета, выводимые пользователю, локализации, с которыми работает виджет. |
| script.js | JS-файл, который будет подключен на стороне пользователя в указанных в manifest.json областях. |
| style.css | CSS-файл стилей виджета, виджет обязательно должен для своих главных элементов использовать уникальный класс и всем дочерним элементом менять стили каскадом относительно базового класса, чтобы не конфликтовать с системными элементами и другими виджетами. |
| images/ | Папка для размещения файлов изображений, которые используются в виджете. Должна содержать в себе 3 файла в формате (**png, jpeg,jpg**или**gif**), которые будут использоваться как логотип виджета в разных областях видимости. Размер каждого файла не должен превышать**300 КБ**. logo\_min.png и logo\_medium.png — обязательно, если виджет работает в карточках, используется во всех списках и карточках контактов или сделок в свернутом и развернутом состоянии соответственно. Также необходимо загрузить logo.png для поддержки старых версий. |
| i18n/ | Папка, содержащая файлы локализаций в формате ключ:значение. На текущий момент возможно использование трех локализаций: русской (ru), английской (en) и испанской (es). Все переводы будут доступны в JS. |
| templates/ | Необязательная папка, может содержать twig-шаблоны, если они используются в виджете. |

Рассмотрим простейший пример виджета, он представляет из себя JS файл, следующего содержания:

```javascript
define(['jquery'], function($) {
'use strict';
return function() {
var self = this;
this.callbacks = {
render: function() {
return true;
},
bind\_actions: function() {
return true;
},
init: function() {
return true;
},
destroy: function() {
// ...
},
settings: function() {
// ...
},
onSave: function() {
return true;
}
};
return this;
};
});
```

При заходе, например, в карточку сделки будет выполнена следующая цепочка вызовов:

1. сначала будет вызван колбэк render, который должен обязательно в итоге вернуть true
   - в этом колбэке виджет должен отрисовать свои необходимые элементы (например, собственный блок в правой колонке виджетов в карточке, используя метод **this.render\_template**)
2. одновременно с ним вызывается колбэк bind\_actions, в нем виджет может добавить необходимые слушатели событий как на собственные элементы, которые только что были отрисованы, так и на какие-то элементы в системе
3. следом за ними будет вызван колбэк **init**, в котором можно делать какие-то действия, когда мы уверены, что виджет уже отрисовал все необходимое и все обработчики тоже готовы к работе

Все три колбэка **обязательно** должны присутствовать в объекте this.callbacks, без них виджет не будет функционировать в указанных областях видимости.

Колбэк **destroy** будет вызван при покидании текущей области видимости (к примеру, при выходе из карточки сделки, если у виджета была область подключения lcard).

Виджет самостоятельно должен хранить свое состояние, то есть в какой области видимости он сейчас проинициализировался, чтобы отрабатывать правильную логику в своих колбэках. Делать это можно на основе APP.getBaseEntity() и APP.isCard(), подробнее про глобальные системные переменные можно почитать [здесь](https://www.amocrm.ru/developers/content/web_sdk/env_variables).

Объект виджета также наследует системный интерфейс объекта **Widget**, который имеет методы, представленные дальше.

Не стоить забывать, что работая через **this** внутри колбеков, вы не сможете обращаться к методам объекта **Widget**. Поэтому мы создаем переменную **self**, но вы можете использовать любой другой удобный для вас способ. Чтобы лучше понять принцип работы, советуем почитать [статью о this](https://doka.guide/js/function-context/) и о [замыканиях](https://javascript.ru/basic/closure).

**self.system();**

Данный метод необходим, для того, чтобы получить системные данные. Данные возвращаются в виде объекта

| Параметр | Описание |
| --- | --- |
| area | Область на которой воспроизводится виджет в данный момент |
| amouser\_id | Id пользователя |
| amouser | Почта пользователя |

Пример ответа:

```javascript
{
area: "ccard" ,
amouser\_id: "103586" ,
amouser: "testuser@amocrm.ru"
}
```

**self.set\_settings();** Метод set\_settings() позволяет добавлять виджету свойства.

```javascript
//создается свойство с именем par1 и значением text
self.set\_settings({ par1: "text" });
// в ответ придет объект с уже созданным свойством
self.get\_settings();
```

**self.get\_settings();**

Данный метод возвращает настройки, которые были сохранены пользователем через модальное окно виджета.

**self.get\_install\_status();**

Данный метод вернет статус установки виджета. Данные возвращаются в виде строки. Возможные значения – **installed** (виджет установлен), **install** (виджет не установлен), **not\_configured** (тур виджета пройден, но настройки не заполнены).

**self.i18n(‘userLang’);**

Возвращает объект с языковыми сообщениями из json-файла текущей локали, по ключу переданному в аргументе.

**self.get\_version();**

Возвращает текущую версию из манифеста, обычно используется для подгрузки чего-либо из сети в качестве идентификатора кеша для браузера, чтобы при обновлении виджета из сети подтягивался актуальный файл.

**self.get\_accounts\_current();**

Возвращает данные по аккаунту без запроса в API и асинхронности (результат не полностью совпадает с ответом API, если нет необходимых данных, то без запроса все-таки не обойтись).

**self.crm\_post(host, data, callback, type);**

Отправляет POST-запрос на внешний сервис, пропуская запрос через amoCRM. Принимает следующие аргументы:

- host – url на который надо отправить запрос
- data – данные, которые отправляем
- callback – выполняется в случае успеха
- type – тип возвращаемых данных (по умолчанию text)

Данный метод не может выполняться чаще одного раза в секунду, если вызовы будут чаще, то отправка запроса будет откладываться на время соразмерное время. То есть если отправить одновременно 5 запросов, то пятый отправится только через 5 секунд. Все остальное время он будет ожидать своей очереди.

**self.render();**

Тут остановимся подробнее, у данного метода есть несколько вариантов использования.

Начать стоит с того, что в системе мы используем twig в качестве основного шаблонизатора, поэтому, если ранее с ним не сталкивались, советуем ознакомиться с [документацией](https://twig.symfony.com/doc/2.x/). В качестве js реализации работает библиотека .

Первый вариант, и тут мы можем шаблон передать строкой и сразу его отрендерить, выглядеть это будет так:

```javascript
self.render({
data: 'The {{ baked\_good }} is a lie.'
}, {
baked\_good: 'cupcake'
});
```

В результате этого вызова получим строку: “The cupcake is a lie.”. Данный метод иногда может пригодиться, но все-таки он не очень удобен из-за того, что шаблон нам по сути надо хранить в виде строки прямо в script.js. Лучше шаблоны отделять от логики виджета и класть в отдельные twig-файлы, таким образом ваш виджет не превратится не нагроможденное месиво из всего подряд.

Поэтому рассмотрим следующие два варианта, они как раз позволяют нам вынести шаблоны в отдельные файлы. Создадим рядом с файлом script.js файл template.twig и перепишем наш render в такой вид:

```javascript
self.render({
href: '/template.twig',
base\_path: self.params.path,
v: self.get\_version(),
load: function (template) {
template.render({
baked\_good: 'cupcake'
});
}
});
```

В данном случае мы подгрузим из сети файл template.twig, после чего отрисуем его. Важный момент, как можно заметить, теперь для того, чтобы шаблон отрисовать надо сначала его загрузить, поэтому метод стал асинхронным.

Ну и третий вариант, в нем отличие от третьего только в том, что с render мы можем работать как с объектом типа promise, поэтому вызов может выглядеть вот так:

```javascript
self.render({
href: '/template.twig',
base\_path: self.params.path,
v: self.get\_version(),
promised: true
}).then(function () {
template.render({
baked\_good: 'cupcake'
});
});
```

Так как у вас может быть много шаблонов, чтобы каждый раз не прописывать кучу параметров в вызове метода render можно воспользоваться следующим модулем (**templates.js**):

```javascript
define(function() {
'use strict';
var instance = null;
return function(context) {
if (!instance && context) {
instance = context;
}
// вспомогательный хелпер для
// работы с шаблонами, нужно вызвать
// один раз с контекстом виджета
return function(template) {
return instance.render({
href: '/templates/' + template + '.twig',
base\_path: instance.params.path,
v: instance.get\_version(),
promised: true
});
};
};
});
```

Script.js при этом может выглядеть вот так:

```javascript
define(['./templates.js'], function(createTemplatesRenderer) {
'use strict';
return function() {
var self = this;
// создаем инстанс
var getTemplate = createTemplatesRenderer(self);
this.callbacks = {
init: function() {
return true;
},
render: function() {
getTemplate('users').then(function(template) {
// делаем что-то с template
});
return true;
},
bind\_actions: function() {
return true;
}
};
return this;
};
});
```

Тут мы подключили модуль templates.js к своему виджету, создали инстанс шаблонов и в методе render вызов getTemplate(‘users’) подгрузит файл users.twig из папки templates виджета и в случае успеха передаст его в then.

Мы хотим, чтобы виджеты выглядели как можно более нативно, поэтому предусмотрели возможность отрисовки стандартных контролов amoCRM в шаблонах виджетов, ниже приведены возможные для использования контролы:

- textarea
- suggest
- select
- radio
- multiselect
- date\_field
- checkbox
- checkboxes\_dropdown
- button
- input

Для использования данных контролов внутри шаблонов виджета предусмотрена специальная функция в twig **include\_control**.

Пример с рендерингом шаблона input:

```twig
{{ include\_control('input', {
class\_name: 'widget\_custom\_class\_name',
name: 'widget\_input',
placeholder: 'Поле для заполнения',
value: 'Сохраненное значение'
}) }}
```

Первый параметр (строка) – код шаблона контрола #TEMPLATE\_NAME#.

Второй параметр (объект) – параметры, которые принимает контрол.

Подробное описание параметров каждого шаблона и примеры использования вы сможете найти в нашем [сторибуке](https://storybook.amocrm.ru).

**self.render\_template()**

Данный метод используется для отрисовки блока виджета в правой панели в карточке и списках. Пример вызова с возможными параметрами:

```javascript
self.render\_template({
caption: {
class\_name: 'js-zoom-caption',
html: ''
},
body: '',
render: '' +
'' + lang['buttonText\_createMeeting'] + '' +
'' +
'' +
'' +
''
});
```

**self.get\_current\_card\_contacts\_data()**

Данный метод не имеет сетевых запросов и предоставляет полезные данные о контактах в области карточки. А именно: в карточках сделки, компании, покупателя предоставляются данные о связанных контактах, а в карточке самого контакта предоставляются данные этого контакта.

Данные возвращаемые методом:

```javascript
[
{
id: number,
name: string,
first\_name: string,
last\_name: string,
phones: [],
emails: []
}
];
```

Метод возвращает промис.

**this.$authorizedAjax()**

Метод отправки ajax-запроса с временным токеном авторизации для текущего пользователя. В запрос добавляется заголовок [X-Auth-Token](/developers/content/oauth/disposable-tokens), удаленный сервер должен разрешить получение запросов с домена аккаунта (настроить [CORS](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS)). Наследует все входящие параметры функции [$.ajax](https://api.jquery.com/jquery.ajax/), в ответ также возвращает полностью совместимый с ответом метода $.ajax объект типа [$.Deferred](https://api.jquery.com/jQuery.Deferred/). Пример вызова:

```javascript
define([], function() {
'use strict';
return function() {
var self = this;
this.callbacks = {
init: function() {
return true;
},
render: function() {
self.$authorizedAjax({
url: 'https://example.com/'
}).done(function (response) {
console.log('success', response);
}).fail(function (err) {
console.log('error', err);
});
return true;
},
bind\_actions: function() {
return true;
}
};
return this;
};
});
```

**self.listenSocketChannel(channel\_name, array\_keys, callback)**

Данный метод используется для подписки на сокет и прослушивания определенных сообщений, которые появляются в канале. Метод возвращает функцию отписки от канала. Принимает следующие аргументы:

- channel\_name (строка) – название канала, который хотим прослушивать
- array\_keys (массив) – массив ключей для фильтрации, если сообщение имеет данные ключи, то оно будет доступно после фильтрации (по умолчанию пустой массив [])
- callback (функция) – функция обработки сообщений сокета (через параметр функции – message передается payload сообщений, которые прошли фильтрацию исходя из array\_keys)

Доступные каналы для прослушивания:

| Канал | Описание |
| --- | --- |
| notifications:${ACCOUNT\_ID}:${USER\_ID} | События по нотификациям |
| inbox:talks:${ACCOUNT\_ID} | События по беседам |
| system:state:${ACCOUNT\_ID} | События по системе |
| ${ENTITY}:card:${CARD\_ID} | События по карточкам сущности |
| dashboard:events | События dashboard |
| ${ENTITY}:pipeline:${PIPELINE\_ID} | События pipeline |
| ${ENTITY}:events | События сущности |

Пример подписки:

```javascript
const channel\_name = `${entity[entity\_type]}:card:${entity\_id}`;
const array\_keys = ['body', 'payload', 'data', 'params'];
const callback = (message) => {
const path = message.data.params;
if (path.old\_value) {
console.log(path.old\_value);
}
};
self.subscription = self.listenSocketChannel(channel\_name, array\_keys, callback);
```

Пример отписки:

```javascript
self.subscription();
```